#!/usr/bin/env python3
"""
GUI tool to compare two text files and find matching and unique entries.
"""

import tkinter as tk
from tkinter import filedialog, messagebox, scrolledtext, ttk
import threading
import os


class FileComparerGUI:
    def __init__(self, root):
        self.root = root
        self.root.title("File Comparison Tool")
        self.root.geometry("700x600")
        
        self.small_file_path = None
        self.large_file_path = None
        self.output_dir = None
        
        self.setup_ui()
    
    def setup_ui(self):
        # Main frame
        main_frame = ttk.Frame(self.root, padding="10")
        main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        # Title
        title_label = ttk.Label(main_frame, text="File Comparison Tool", 
                                font=('Arial', 16, 'bold'))
        title_label.grid(row=0, column=0, columnspan=3, pady=10)
        
        # Small file selection
        ttk.Label(main_frame, text="Small file (~40 rows):").grid(row=1, column=0, sticky=tk.W, pady=5)
        self.small_file_label = ttk.Label(main_frame, text="No file selected", 
                                          foreground="gray", wraplength=400)
        self.small_file_label.grid(row=1, column=1, sticky=tk.W, padx=5)
        ttk.Button(main_frame, text="Browse...", command=self.select_small_file).grid(row=1, column=2, padx=5)
        
        # Large file selection
        ttk.Label(main_frame, text="Large file (~1.7M rows):").grid(row=2, column=0, sticky=tk.W, pady=5)
        self.large_file_label = ttk.Label(main_frame, text="No file selected", 
                                          foreground="gray", wraplength=400)
        self.large_file_label.grid(row=2, column=1, sticky=tk.W, padx=5)
        ttk.Button(main_frame, text="Browse...", command=self.select_large_file).grid(row=2, column=2, padx=5)
        
        # Output directory selection
        ttk.Label(main_frame, text="Output directory:").grid(row=3, column=0, sticky=tk.W, pady=5)
        self.output_dir_label = ttk.Label(main_frame, text="Same as large file", 
                                          foreground="gray", wraplength=400)
        self.output_dir_label.grid(row=3, column=1, sticky=tk.W, padx=5)
        ttk.Button(main_frame, text="Browse...", command=self.select_output_dir).grid(row=3, column=2, padx=5)
        
        # Compare button
        self.compare_button = ttk.Button(main_frame, text="Compare Files", 
                                        command=self.start_comparison, state=tk.DISABLED)
        self.compare_button.grid(row=4, column=0, columnspan=3, pady=20)
        
        # Progress bar
        self.progress = ttk.Progressbar(main_frame, mode='indeterminate', length=400)
        self.progress.grid(row=5, column=0, columnspan=3, pady=5)
        
        # Status/Results text area
        ttk.Label(main_frame, text="Status / Results:").grid(row=6, column=0, columnspan=3, sticky=tk.W, pady=(10,0))
        self.status_text = scrolledtext.ScrolledText(main_frame, height=15, width=80, wrap=tk.WORD)
        self.status_text.grid(row=7, column=0, columnspan=3, pady=5)
        
        # Configure grid weights
        self.root.columnconfigure(0, weight=1)
        self.root.rowconfigure(0, weight=1)
        main_frame.columnconfigure(1, weight=1)
        main_frame.rowconfigure(7, weight=1)
    
    def select_small_file(self):
        filepath = filedialog.askopenfilename(
            title="Select small file (~40 rows)",
            filetypes=[("Text files", "*.txt"), ("All files", "*.*")]
        )
        if filepath:
            self.small_file_path = filepath
            self.small_file_label.config(text=os.path.basename(filepath), foreground="black")
            self.check_ready()
    
    def select_large_file(self):
        filepath = filedialog.askopenfilename(
            title="Select large file (~1.7M rows)",
            filetypes=[("Text files", "*.txt"), ("All files", "*.*")]
        )
        if filepath:
            self.large_file_path = filepath
            self.large_file_label.config(text=os.path.basename(filepath), foreground="black")
            if not self.output_dir:
                self.output_dir = os.path.dirname(filepath)
                self.output_dir_label.config(text=self.output_dir, foreground="black")
            self.check_ready()
    
    def select_output_dir(self):
        directory = filedialog.askdirectory(title="Select output directory")
        if directory:
            self.output_dir = directory
            self.output_dir_label.config(text=directory, foreground="black")
    
    def check_ready(self):
        if self.small_file_path and self.large_file_path:
            self.compare_button.config(state=tk.NORMAL)
    
    def log(self, message):
        self.status_text.insert(tk.END, message + "\n")
        self.status_text.see(tk.END)
        self.status_text.update()
    
    def start_comparison(self):
        self.compare_button.config(state=tk.DISABLED)
        self.status_text.delete(1.0, tk.END)
        self.progress.start()
        
        # Run comparison in separate thread to keep GUI responsive
        thread = threading.Thread(target=self.compare_files)
        thread.start()
    
    def normalize_string(self, s):
        """Normalize string: uppercase and remove all whitespace for comparison"""
        return ''.join(s.upper().split())
    
    def compare_files(self):
        try:
            self.log(f"Reading small file: {os.path.basename(self.small_file_path)}")
            
            small_lines = []
            with open(self.small_file_path, 'r', encoding='utf-8') as f:
                for line in f:
                    line = line.strip()
                    if line:
                        small_lines.append(line)
            
            self.log(f"Found {len(small_lines)} entries in small file\n")
            
            self.log(f"Reading large file and searching for matches: {os.path.basename(self.large_file_path)}")
            
            # Build normalized lookup for small lines
            small_normalized = {self.normalize_string(line): line for line in small_lines}
            
            # Track matches: small_line -> list of (large_line, line_number)
            matches = {line: [] for line in small_lines}
            large_row_count = 0
            
            with open(self.large_file_path, 'r', encoding='utf-8') as f:
                for i, large_line in enumerate(f, 1):
                    large_row_count = i
                    large_line = large_line.strip()
                    
                    if not large_line:
                        continue
                    
                    large_normalized = self.normalize_string(large_line)
                    
                    # Check if any small line is a substring of this large line
                    for small_norm, small_orig in small_normalized.items():
                        if small_norm in large_normalized:
                            matches[small_orig].append((large_line, i))
                    
                    if i % 100000 == 0:
                        matched_count = sum(1 for v in matches.values() if len(v) > 0)
                        self.log(f"  Processed {i:,} rows... Found matches for {matched_count} entries so far")
            
            self.log(f"\nProcessed {large_row_count:,} rows from large file")
            
            # Separate matched and unique entries
            matched_entries = {k: v for k, v in matches.items() if len(v) > 0}
            unique_entries = [k for k, v in matches.items() if len(v) == 0]
            
            # Write results
            base_name = os.path.splitext(os.path.basename(self.small_file_path))[0]
            matches_file = os.path.join(self.output_dir, f"{base_name}_matches.txt")
            unique_file = os.path.join(self.output_dir, f"{base_name}_unique.txt")
            
            # Write matched entries with details
            with open(matches_file, 'w', encoding='utf-8') as f:
                f.write("# Matched entries (case-insensitive, whitespace-ignored substring matching)\n")
                f.write("# Shows: Small file entry | Number of matches | First match from large file\n\n")
                
                for small_line in sorted(matched_entries.keys()):
                    match_list = matched_entries[small_line]
                    num_matches = len(match_list)
                    first_match_line, first_match_num = match_list[0]
                    
                    f.write(f"Small file entry:\n  {small_line}\n")
                    f.write(f"Number of matches: {num_matches}\n")
                    f.write(f"First match (line {first_match_num}):\n  {first_match_line}\n")
                    
                    if num_matches > 1:
                        f.write(f"Additional matches found at lines: ")
                        f.write(", ".join(str(line_num) for _, line_num in match_list[1:]))
                        f.write("\n")
                    
                    f.write("\n" + "-"*80 + "\n\n")
            
            # Write unique entries (not found in large file)
            with open(unique_file, 'w', encoding='utf-8') as f:
                f.write("# Entries from small file NOT found in large file\n")
                f.write("# (case-insensitive, whitespace-ignored substring search)\n\n")
                
                for line in unique_entries:
                    f.write(f"{line}\n")
            
            # Print summary
            self.log("\n" + "="*60)
            self.log("SUMMARY")
            self.log("="*60)
            self.log(f"Total entries in small file: {len(small_lines)}")
            self.log(f"Entries found in large file: {len(matched_entries)}")
            self.log(f"Unique entries (not in large file): {len(unique_entries)}")
            
            # Show multiple match statistics
            multi_match_count = sum(1 for v in matched_entries.values() if len(v) > 1)
            if multi_match_count > 0:
                self.log(f"Entries with multiple matches: {multi_match_count}")
            
            self.log(f"\nResults written to:")
            self.log(f"  - {matches_file}")
            self.log(f"  - {unique_file}")
            self.log("="*60)
            
            messagebox.showinfo("Success", "Comparison completed successfully!")
            
        except Exception as e:
            self.log(f"\nERROR: {str(e)}")
            messagebox.showerror("Error", f"An error occurred:\n{str(e)}")
        
        finally:
            self.progress.stop()
            self.compare_button.config(state=tk.NORMAL)


def main():
    root = tk.Tk()
    app = FileComparerGUI(root)
    root.mainloop()


if __name__ == "__main__":
    main()
