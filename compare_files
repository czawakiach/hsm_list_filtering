#!/usr/bin/env python3
"""
GUI tool to compare two text files and find matching and unique entries.
"""

import tkinter as tk
from tkinter import filedialog, messagebox, scrolledtext, ttk
import threading
import os


class FileComparerGUI:
    def __init__(self, root):
        self.root = root
        self.root.title("File Comparison Tool")
        self.root.geometry("700x600")
        
        self.small_file_path = None
        self.large_file_path = None
        self.output_dir = None
        
        self.setup_ui()
    
    def setup_ui(self):
        # Main frame
        main_frame = ttk.Frame(self.root, padding="10")
        main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        # Title
        title_label = ttk.Label(main_frame, text="File Comparison Tool", 
                                font=('Arial', 16, 'bold'))
        title_label.grid(row=0, column=0, columnspan=3, pady=10)
        
        # Small file selection
        ttk.Label(main_frame, text="Small file (~40 rows):").grid(row=1, column=0, sticky=tk.W, pady=5)
        self.small_file_label = ttk.Label(main_frame, text="No file selected", 
                                          foreground="gray", wraplength=400)
        self.small_file_label.grid(row=1, column=1, sticky=tk.W, padx=5)
        ttk.Button(main_frame, text="Browse...", command=self.select_small_file).grid(row=1, column=2, padx=5)
        
        # Large file selection
        ttk.Label(main_frame, text="Large file (~1.7M rows):").grid(row=2, column=0, sticky=tk.W, pady=5)
        self.large_file_label = ttk.Label(main_frame, text="No file selected", 
                                          foreground="gray", wraplength=400)
        self.large_file_label.grid(row=2, column=1, sticky=tk.W, padx=5)
        ttk.Button(main_frame, text="Browse...", command=self.select_large_file).grid(row=2, column=2, padx=5)
        
        # Output directory selection
        ttk.Label(main_frame, text="Output directory:").grid(row=3, column=0, sticky=tk.W, pady=5)
        self.output_dir_label = ttk.Label(main_frame, text="Same as large file", 
                                          foreground="gray", wraplength=400)
        self.output_dir_label.grid(row=3, column=1, sticky=tk.W, padx=5)
        ttk.Button(main_frame, text="Browse...", command=self.select_output_dir).grid(row=3, column=2, padx=5)
        
        # Compare button
        self.compare_button = ttk.Button(main_frame, text="Compare Files", 
                                        command=self.start_comparison, state=tk.DISABLED)
        self.compare_button.grid(row=4, column=0, columnspan=3, pady=20)
        
        # Progress bar
        self.progress = ttk.Progressbar(main_frame, mode='indeterminate', length=400)
        self.progress.grid(row=5, column=0, columnspan=3, pady=5)
        
        # Status/Results text area
        ttk.Label(main_frame, text="Status / Results:").grid(row=6, column=0, columnspan=3, sticky=tk.W, pady=(10,0))
        self.status_text = scrolledtext.ScrolledText(main_frame, height=15, width=80, wrap=tk.WORD)
        self.status_text.grid(row=7, column=0, columnspan=3, pady=5)
        
        # Configure grid weights
        self.root.columnconfigure(0, weight=1)
        self.root.rowconfigure(0, weight=1)
        main_frame.columnconfigure(1, weight=1)
        main_frame.rowconfigure(7, weight=1)
    
    def select_small_file(self):
        filepath = filedialog.askopenfilename(
            title="Select small file (~40 rows)",
            filetypes=[("Text files", "*.txt"), ("All files", "*.*")]
        )
        if filepath:
            self.small_file_path = filepath
            self.small_file_label.config(text=os.path.basename(filepath), foreground="black")
            self.check_ready()
    
    def select_large_file(self):
        filepath = filedialog.askopenfilename(
            title="Select large file (~1.7M rows)",
            filetypes=[("Text files", "*.txt"), ("All files", "*.*")]
        )
        if filepath:
            self.large_file_path = filepath
            self.large_file_label.config(text=os.path.basename(filepath), foreground="black")
            if not self.output_dir:
                self.output_dir = os.path.dirname(filepath)
                self.output_dir_label.config(text=self.output_dir, foreground="black")
            self.check_ready()
    
    def select_output_dir(self):
        directory = filedialog.askdirectory(title="Select output directory")
        if directory:
            self.output_dir = directory
            self.output_dir_label.config(text=directory, foreground="black")
    
    def check_ready(self):
        if self.small_file_path and self.large_file_path:
            self.compare_button.config(state=tk.NORMAL)
    
    def log(self, message):
        self.status_text.insert(tk.END, message + "\n")
        self.status_text.see(tk.END)
        self.status_text.update()
    
    def start_comparison(self):
        self.compare_button.config(state=tk.DISABLED)
        self.status_text.delete(1.0, tk.END)
        self.progress.start()
        
        # Run comparison in separate thread to keep GUI responsive
        thread = threading.Thread(target=self.compare_files)
        thread.start()
    
    def extract_after_russia_small(self, line):
        """Extract everything from 'RUSSIA/' onwards (case-insensitive)"""
        line_upper = line.upper()
        idx = line_upper.find('RUSSIA/')
        if idx != -1:
            return line[idx:].strip().upper()  # Return in uppercase for case-insensitive comparison
        return None
    
    def extract_after_russia_large(self, line):
        """Extract everything from 'RUSSIA' onwards (case-insensitive)"""
        line_upper = line.upper()
        idx = line_upper.find('RUSSIA')
        if idx != -1:
            return line[idx:].strip().upper()  # Return in uppercase for case-insensitive comparison
        return None
    
    def compare_files(self):
        try:
            self.log(f"Reading small file: {os.path.basename(self.small_file_path)}")
            self.log("Extracting patterns after 'RUSSIA/' ...\n")
            
            small_entries = {}  # Map extracted pattern -> original line
            small_patterns = set()
            skipped_small = 0
            
            with open(self.small_file_path, 'r', encoding='utf-8') as f:
                for line in f:
                    line = line.strip()
                    if not line:
                        continue
                    
                    pattern = self.extract_after_russia_small(line)
                    if pattern:
                        small_patterns.add(pattern)
                        if pattern not in small_entries:
                            small_entries[pattern] = line  # Store original line for reference
                    else:
                        skipped_small += 1
            
            self.log(f"Found {len(small_patterns)} unique patterns with 'RUSSIA/' in small file")
            if skipped_small > 0:
                self.log(f"Skipped {skipped_small} lines without 'RUSSIA/' pattern\n")
            else:
                self.log("")
            
            self.log(f"Reading and comparing with large file: {os.path.basename(self.large_file_path)}")
            self.log("Extracting patterns after 'RUSSIA' ...\n")
            
            matches = {}  # Map pattern -> (small_line, large_line)
            large_row_count = 0
            skipped_large = 0
            
            with open(self.large_file_path, 'r', encoding='utf-8') as f:
                for i, line in enumerate(f, 1):
                    large_row_count = i
                    line = line.strip()
                    
                    if not line:
                        continue
                    
                    pattern = self.extract_after_russia_large(line)
                    if pattern:
                        if pattern in small_patterns:
                            if pattern not in matches:
                                matches[pattern] = (small_entries[pattern], line)
                    else:
                        skipped_large += 1
                    
                    if i % 100000 == 0:
                        self.log(f"  Processed {i:,} rows... Found {len(matches)} matches so far")
            
            self.log(f"\nProcessed {large_row_count:,} rows from large file")
            if skipped_large > 0:
                self.log(f"Skipped {skipped_large:,} lines without 'RUSSIA' pattern")
            
            unique_patterns = small_patterns - set(matches.keys())
            unique_entries = {pattern: small_entries[pattern] for pattern in unique_patterns}
            
            # Write results
            base_name = os.path.splitext(os.path.basename(self.small_file_path))[0]
            matches_file = os.path.join(self.output_dir, f"{base_name}_matches.txt")
            unique_file = os.path.join(self.output_dir, f"{base_name}_unique.txt")
            matches_detail_file = os.path.join(self.output_dir, f"{base_name}_matches_detail.txt")
            
            # Write matched patterns
            with open(matches_file, 'w', encoding='utf-8') as f:
                f.write("# Matched patterns (case-insensitive comparison)\n")
                f.write("# Pattern | Small file line | Large file line\n\n")
                for pattern in sorted(matches.keys()):
                    small_line, large_line = matches[pattern]
                    f.write(f"{pattern}\n")
            
            # Write matched patterns with details
            with open(matches_detail_file, 'w', encoding='utf-8') as f:
                f.write("# Detailed matches showing original lines from both files\n")
                f.write("# Format: Pattern | Small file | Large file\n\n")
                for pattern in sorted(matches.keys()):
                    small_line, large_line = matches[pattern]
                    f.write(f"Pattern: {pattern}\n")
                    f.write(f"  Small: {small_line}\n")
                    f.write(f"  Large: {large_line}\n\n")
            
            # Write unique patterns (not found in large file)
            with open(unique_file, 'w', encoding='utf-8') as f:
                f.write("# Patterns from small file NOT found in large file\n")
                f.write("# Pattern | Original line\n\n")
                for pattern in sorted(unique_entries.keys()):
                    original_line = unique_entries[pattern]
                    f.write(f"{pattern}\n")
                    f.write(f"  Original: {original_line}\n\n")
            
            # Print summary
            self.log("\n" + "="*60)
            self.log("SUMMARY")
            self.log("="*60)
            self.log(f"Total patterns in small file: {len(small_patterns)}")
            self.log(f"Patterns found in large file: {len(matches)}")
            self.log(f"Unique patterns (not in large file): {len(unique_entries)}")
            self.log(f"\nResults written to:")
            self.log(f"  - {matches_file}")
            self.log(f"  - {matches_detail_file}")
            self.log(f"  - {unique_file}")
            self.log("="*60)
            
            messagebox.showinfo("Success", "Comparison completed successfully!")
            
        except Exception as e:
            self.log(f"\nERROR: {str(e)}")
            messagebox.showerror("Error", f"An error occurred:\n{str(e)}")
        
        finally:
            self.progress.stop()
            self.compare_button.config(state=tk.NORMAL)


def main():
    root = tk.Tk()
    app = FileComparerGUI(root)
    root.mainloop()


if __name__ == "__main__":
    main()
